# ADR-020: Confluence Generator Dependency Architecture

**Status:** Accepted
**Date:** 2025-09-25
**Deciders:** Architecture Team

## Context

The `@confytome/confluence` generator currently depends on `@confytome/markdown` to generate markdown content, which it then processes for Confluence compatibility. This raises architectural questions about dependency direction and code reuse patterns within the monorepo.

### Current Architecture
```
@confytome/confluence → @confytome/markdown → @confytome/core
```

### Alternative Architectures Considered

1. **Direct Core Dependency**
```
@confytome/confluence → @confytome/core
@confytome/markdown → @confytome/core
```

2. **Shared Template Dependency**
```
@confytome/confluence → @confytome/templates
@confytome/markdown → @confytome/templates
@confytome/templates → @confytome/core
```

3. **Plugin Architecture**
```
@confytome/confluence → @confytome/core (with plugin interface)
@confytome/markdown → @confytome/core (with plugin interface)
```

## Decision

**We will maintain the current architecture where `@confytome/confluence` depends on `@confytome/markdown`.**

## Rationale

### Advantages of Current Architecture

1. **Functional Correctness**: Confluence output is fundamentally markdown that gets copied to clipboard - it IS markdown with specific formatting requirements
2. **Zero Code Duplication**: No duplicate template logic, processing code, or formatting rules
3. **Automatic Feature Parity**: All markdown improvements (tag-based sectioning, parameter examples, UTF-8 support) automatically benefit confluence users
4. **Simplified Testing**: Single source of truth for output formatting reduces test surface area
5. **Clear Responsibility Separation**:
   - Core: OpenAPI processing and data transformation
   - Markdown: Template rendering and markdown generation
   - Confluence: Clipboard integration and Confluence-specific workflow
6. **Maintenance Efficiency**: Changes to documentation format only need to be made in one place

### Why Alternative Architectures Were Rejected

**Direct Core Dependency:**
- ❌ Would require duplicating all template logic and formatting rules
- ❌ Risk of confluence and markdown outputs diverging over time
- ❌ Increased maintenance burden with two template systems
- ❌ No clear benefit since confluence output IS markdown

**Shared Template Dependency:**
- ❌ Over-engineering for current requirements
- ❌ Adds complexity without solving a real problem
- ❌ Would still need format-specific logic in both generators

**Plugin Architecture:**
- ❌ Significantly more complex than current simple approach
- ❌ No clear benefit for the current two-generator scenario
- ❌ Would complicate the standalone generator pattern

### Technical Implementation Details

The current implementation correctly models the relationship:
```javascript
// Confluence generator delegates markdown generation
const markdownGenerator = new StandaloneMarkdownGenerator(this.outputDir, {
  specPath: this.options.specPath,
  excludeBrand: this.options.excludeBrand,
  urlEncodeAnchors: this.options.urlEncodeAnchors
});

const result = await markdownGenerator.generate();
// Then processes for Confluence (clipboard, etc.)
```

### Dependency Direction Analysis

The dependency `confluence → markdown → core` is natural because:
- Confluence **IS-A** markdown workflow (with clipboard integration)
- Markdown **USES** core processing capabilities
- This follows the Dependency Inversion Principle correctly

## Consequences

### Positive
- ✅ Guaranteed feature parity between generators
- ✅ Single source of truth for documentation format
- ✅ Reduced maintenance burden
- ✅ Clear, understandable architecture
- ✅ Efficient development workflow

### Negative
- ⚠️ Confluence generator has transitive dependency on markdown templates
- ⚠️ Breaking changes in markdown could affect confluence (mitigated by semantic versioning)
- ⚠️ Slightly larger package size for confluence users (minimal impact)

### Monitoring

We will monitor:
1. User feedback on confluence output quality
2. Performance impact of dependency chain
3. Maintenance overhead of shared formatting logic

### Future Considerations

If additional output formats are needed (e.g., AsciiDoc, reStructuredText), we should:
1. First evaluate if they can build on markdown (like confluence does)
2. Only create direct core dependencies if the output format is fundamentally different
3. Consider shared template abstraction only if we have 3+ independent template systems

## Implementation Notes

Current implementation satisfies all requirements:
- ✅ Tag-based sectioning via shared `OpenApiProcessor`
- ✅ Parameter examples with complex object support
- ✅ Hierarchical Quick Reference structure
- ✅ UTF-8 Turkish character support
- ✅ URL encoding options pass-through
- ✅ Authentication section prioritization

## References

- [Workspace Architecture Documentation](../CLAUDE.md#structure)
- [Plugin Interface Pattern](../../packages/core/utils/StandaloneBase.js)
- [Dependency Inversion Principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle)